.fp 5 H
.PH "''''"
.PF "''-\\\\nP-''"
.S +1
.EQ
gsize +1
define 1st ' rom "1st" '
define 2nd ' rom "2nd" '
define RR ' roman '
.EN
.DS 2
.ul
FOUR RELATIONAL PROGRAMS\u*\d
.sp
B. J. MacLennan
Computer Science Department
Naval Postgraduate School
Monterey, CA 93943
.DE
.FS *
The work reported herein was supported by Contract N00014-85-WR-24057
from the Office of Naval Research.
.FE
.B Abstract:
.sp
.br
In this report we demonstrate the relational programming language
RPL by using it to develop four programs.
These programs are: (1) computing a table of word frequencies from a text;
(2) minimizing a deterministic finite state automata;
(3) Gaussian elimination; and (4) a simple data processing example
involving updating an employee file.
Appendix A shows transcripts of executions of the programs
on the Brown and Mitton interpreter [Brown&Mitton].
The reader is presumed to be familiar with RPL, which is described
in [MacLennan83].
For convenience, however,
Appendix B contains the RPL grammar, and Appendix C describes
the language accepted by the Brown and Mitton interpreter.
.H 1 "Computing Word Frequencies"
The first example, which is adapted from [MacLennan83], it to compute a
frequence table $F$ from a text (sequence of words) $S$.
That is, given $S$ such that
$S sel i$ is the $i sup th$ word, we compute $F$ such that
$F sel w$ is the frequency (number of occurrences) of word $w$ in $S$.
For an example, we take 
$S$ = <``to'', ``be'', ``or'', ``not'', ``to'', ``be''>, which is just an
abbreviation for the relation:
.DS 2
$S$  =  {1:``to'', 2:``be'', 3:``or'', 4:``not'', 5:``to'', 6:``be''}
.DE
Pictorially,
.DS 
.TS
center,box;
l|l.
1	``to''
2	``be''
3	``or''
4	``not''
5	``to''
6	``be''
.TE
.DE
In this case, the desired frequency table $F$ is:
.DS 2
$F$  =  {``to'':2, ``be'':2, ``or'':1, ``not'':1}
.DE
Pictorially,
.DS 
.TS
center,box;
l|l.
``to''	2
``be''	2
``or''	1
``not''	1
.TE
.DE
In other words, ``to'' occurs twice, ``be'' occurs twice, ``or'' occurs once,
and ``not'' occurs once.
Of course, since $F$ is a relation, the order in which the elements are listed
is irrelevant.
.P
To develop the general word-counting program, we work through this
particular example.
Since the frequency table is a function 
.ul
from 
the words 
.ul
to
their frequencies, the first step is to reverse columns of $S$:
.DS 2
$S sup -1$  =  {``to'':1, ``be'':2, ``or'':3, ``not'':4, ``to'':5, ``be'':6}
.DE
Pictorially,
.DS 
.TS
center,box;
l|l.
``to''	1
``be''	2
``or''	3
``not''	4
``to''	5
``be''	6
.TE
.DE
Notice that this relation is not a function (i.e., it is not single valued).
We can make it a function by
forming the ``unit image'' of the table:\*F
.FS
This function is related to the RPL $size -2 unimg$ operator; see below.
.FE
.DS 2
$rom unimage~S sup -1$  =  {``to'':{1, 5}, ``be'':{2, 6}, ``or'':{3}, ``not'':{4}}
.DE
Pictorially,
.DS 
.TS
center,box;
l|l.
``to''	{1, 5}
``be''	{2, 6}
``or''	{3}
``not''	{4}
.TE
.DE
This tells us, for example, that the word ``be'' occurs in positions 2 and 6
in the text.
We do not need to know the places where a given word occurs, but only
the number of such places.
Therefore, we send the preceding table
through the $card$ (cardinality) function (by the relative product operation):
.DS 2
$rom unimage~S sup -1~rp~card$  =  {``to'':2, ``be'':2, ``or'':1, ``not'':1}
.DE
This is the desired result; the final step is depicted in Figure 1.
.DF 
\l'6.5i'

.TS
center,box;
l|l.
``to''	{1, 5}
``be''	{2, 6}
``or''	{3}
``not''	{4}
.TE
.ce
.sp
$rp$
.sp
.TS
center,box;
l|l.
{}	0
{1}	1
{4}	1
{2, 6}	2
{4, 8}	2
{4, 6, 7}	3

$3dot$	$3dot$

.TE
.ce
.sp
$||$
.sp
.TS
center,box;
l|l.
``to''	2
``be''	2
``or''	1
``not''	1
.TE

.FG "Piping $rom unimage~S sup -1$ Through $card$ Function"
\l'6.5i'
.DE
Notice that since $card$ is defined for all sets, it is in effect an
infinite relation; this is permitted in RPL.
.P
The resulting program is:
.DS 2
$F~==~rom unimage~S sup -1~rp~card$
.DE
We can turn it into a function definition to compute
the frequency table for any text $S$ by:
.DS 2
$rom freq~S~~==~~rom unimage~S sup -1 ~rp~card$
.DE
It remains to define the `$rom unimage$' function, which is not built into RPL.
On the other hand, RPL does have the builtin operator $unimg$, defined to
that $T~unimg~x$ is the set of all $y$ such that $x : y~member~T$.
This can be used to define $rom unimage$.
To see this, note that the
.ul
left section
$[T~unimg ]$ is the function that takes any $x$ into its image under $T$.
Although $T$ is finite (and extensional), sections are always intensional,
so it is necessary to to convert $[T~unimg ]$ to its extensional
equivalent.
This is accomplished with the RPL $restrict$ operation, which converts
an intensional relation to an extensional relation by restricting
its domain to a finite set.
Hence we define:
.DS 2
$rom unimage~T~~==~~dom~T~~restrict~~[T~unimg ]$
.DE
.P
The following is an example RPL session that defines the $rom freq$ function
an applies it to a particular text (`?>' is the RPL prompt):
.DS 1
?> $rom unimage~T~~==~~dom T~restrict~[T~unimg ]$

?> $rom freq~S~~==~~ rom unimage~ S sup -1   ~rp~card $

?> freq <``to'', ``be'', ``or'', ``not'', ``to'', ``be''>

{``be'':2, ``to'':2, ``not'':1, ``or'':1}

?> $done$
.DE
The appendix contains
the actual transcript of this RPL session; it shows how programs must
be represented for the Brown and Mitton interpreter.
The preceding formulas were produced from this transcript by a pretty printer.
.H 1 "Minimization of Deterministic Finite Automata"
The next example program is the equivalence
and minimization of deterministic finite automata
by an algorithm developed by Robert Floyd.\*F
.FS
Private communication, 1985.
.FE
We assume that we have a finite alphabet $SIGMA$ and
a finite set $Q$ of states.
The set $F~!subset~Q$ represents the 
.ul
final 
(accepting) states.
The finite relation $T$ is such that for $a member SIGMA$,
$T sel a$ is the transition relation for the symbol $a$.
That is, $<q ,~q' >~member~T~sel~a$ if and only if the
symbol $a$ takes state $q$ into state $q'$.
.P
Our goal is to define a relation $R sub inf$ such that
$<q ,~q' >~member~R sub inf$ if and only if $q$ and $q'$ are
.ul
not
equivalent states.
This is done in a series of steps, starting from pairs of
states that are known to be inequivalent, namely the
final and nonfinal states:
.DS 2
$R sub 0~~==~~F~cart~(Q~setdif~F)$
.DE
We now work backward:  any states that under the same input lead
to inequivalent states are themselves considered inequivalent.
For example, $R sub 0$ relates inequivalent states;
$R sub 1$ relates states related by $R sub 0$ together with those
that under the same input character
are taken into states related by $R sub 0$; $R sub 2$ relates states 
related by $R sub 0$ together with those that under the same one
or two input characters lead to states
related by $R sub 0$; and so on.
Each step of this process is accomplished by a function $psi$;
that is, we will define $psi$ so that $R sub i+1~~=~~psi~R sub i$.
It will be easy to see that this process converges in $n~=~( card~Q) sup 2$
steps, so
.DS 2
$R sub inf~~==~~psi sup n ~R sub 0$
.DE
Next we consider $psi$.
.P
As a preliminary we define the
.ul
polymorphic image
of one relation under another relation.
If $R$ and $S$ are two relations, then the polymorphic image under $R$
of $S$, or more briefly the $R$-image of $S$, is defined
.DS 2
$R~ppd~S~~==~~R~|~S~|~R sup -1$
.DE
This has the following property:
$R~ppd~S$ relates $x$ to $y$ if and only if there are $u$ and $v$
such that $R$ relates $x$ to $u$ and $y$ to $v$, and $S$ relates
$u$ to $v$.
That is, $<x,~y>~member~R~ppd~S$ if and only if there are $u$ and $v$
such that $<x,~u>~member~R$, $<y,~v>~member~R$ and $<u,~v>~member~S$.
This can be visualized:
.DS 
.PS
boxwid = .25i
boxht = .25i
move right 3i
X: box invis "$x$"
arrow right "$R$" above
U: box invis "$u$"
arrow down from U.s "$~S$" ljust
V: box invis "$v$"
arrow <- left from V.w "$R$" below
Y: box invis "$y$"
arrow "$R~ppd~S~$" rjust dotted from X.s to Y.n
.PE
.DE
.P
Now, if we have that $R sub i$ relates inequivalent states,
then $(T~sel~a)~ppd~R sub i$ will relate those states that
are carried by symbol $a$ into states inequivalent by $R sub i$.
Thus, we define $R sub i+1$ so that it relates those states that are related by
$R sub i$ together with those related by $(T~sel~a)~ppd~R sub i$,
for any $a~member~SIGMA$.
Now, if by $[ ppd~R sub i ]$ we mean the function that takes
a polymorphic image of $R sub i$, that is,
.DS 2
$[ ppd~R sub i ]~x~~=~~x~ppd~R sub i$
.DE
then it is easy to see that
.DS 2
$(T~|~[ ppd~R sub i ])~sel~a~~=~~[ ppd~R sub i ]~(T~sel~a)~~=~~(T~sel~a)~ppd~R sub i$
.DE
Hence, the union of $(T~sel~a)~ppd~R sub i$, for all $a~member~SIGMA$,
is just the union of the
range of the relation $T~|~[ ppd~R sub i ]$.
This yields the definition of $R sub i$ and hence $psi$:
.DS 2
$R sub i+1~~==~~psi~R sub i~~==~~R sub i~cup~union ( rng~(T~|~[ ppd~R sub i ]) )$
.DE
This completes the definition of the inequivalence relation $R sub inf$.
Two states are now equivalent if they are not inequivalent:
.DS 2
$R sub = ~~==~~Q sup 2~setdif~(R sub inf ~cup~R sub inf sup -1  )$
.DE
where $Q sup 2$ means $Q~cart~Q$.
.P
The minimal machine is constructed on the basis of the equivalence
classes of states under $R sub =$.
The equivalence class of a state $q$ is just the unit image under
$R sub =$ of $q$:
.DS 2
$rom eclass~q~~==~~R sub =~unimg~q$
.DE
The set of all such equivalence classes results from taking
the image of $Q$ under $rom eclass$:
.DS 2
$Q sub =~~==~~rom eclass~img~Q$
.DE
In general, we define 
.DS 2
$rom equiv~~==~~[ rom eclass~img ]$,
.DE
so $Q sub =~~==~~rom equiv~Q$.
We take $Q sub =$ to be the states in the minimal machine.
.P
It remains to construct the transition relation $T sub =$
of the minimal machine.
For all $<q,~q' >~member~T~sel~a$ we want
.DS 2
$< rom eclass~q,~rom eclass~q' >~member~T sub =~sel~a$
.DE
Thus $T sub =~sel~a$ is the
.ul
isomorphic image
under $rom eclass$ of $T~sel~a$:
.DS 2
$T sub =~sel~a~~=~~rom eclass~isom~(T~sel~a)$
.DE
Thus $T sub =$ is the (finite) composition of $[ rom eclass~isom ]$
and $T$, which is the (finite) relative product of $T$
and $[ rom eclass~isom ]$:
.DS 2
$T sub =~~==~~T~|~[ rom eclass~isom ]$
.DE
The remainder of the minimal machine is easy to construct.
For example, the final states are just the equivalence
classes of the original final states:
.DS 2
$F sub =~~==~~rom equiv~F$
.DE
There follows the actual relational program to minimize
a small automaton.
It makes use of two auxiliary functions $sigma$ and $rho$
for defining the union of a set of sets:

-- DFA Minimization

-- Utility Functions
.DS 1
         $1st~~mark ==~~ [ sel~1 ] $
$2nd~~lineup ==~~ [ sel~2 ] $
$r~ppd~s~~lineup ==~~ r~|~  s~|~r sup -1 $
$sigma~f~~lineup ==~~  ( f~o~ ( 1st~ , bar ~ ( epsilon~o~2nd )  )  ) ~ , bar ~ (  [ setdif ] ~o~   ( I~ , bar ~ ( un~o~epsilon )  ) ~o~2nd   )  ) $
$f~rho~i~~lineup ==~~ 1st~o~   (   sigma~f  ~while~ (  [ !=~empty ] ~o~2nd )  ) ~o~ [ i~, ]    $
$union~~lineup ==~~  [ cup ] ~rho~empty  $
.DE
-- Example DFA
.DS 1
$SIGMA~~lineup ==~~ "{" 1,~2 "}" $
$T~~lineup ==~~ "{"  1~:~ "{"  10~:~10 , ~ 20~:~20 "}", ~  2~:~ "{"   10~:~30 , ~  20~:~30"}" "}"$
$Q~~lineup ==~~ "{" 10,~20,~30 "}" $
$F~~lineup ==~~ "{" 30 "}" $
.DE
.SK
-- Minimization
.DS 1
$Q sup 2~~lineup ==~~ Q~cart~Q  $
$n~~lineup ==~~ card~Q sup 2  $
$R sub 0~~lineup ==~~ F~cart~ ( Q~setdif~F )  $
$psi~R~~lineup ==~~ R~cup~  union ( rng~ ( T~rp~ [ ppd~R ]    )  ) $
$R sub inf~~lineup ==~~  psi sup n  ~R sub 0  $
$R sub =~~lineup ==~~  Q sup 2~setdif~(R sub inf ~cup~ R sub inf sup -1 )   $
$rom eclass~~lineup ==~~ [ R sub =~unimg ] $
$rom equiv~~lineup ==~~  [ rom eclass~img ]$
$Q sub =~~lineup ==~~ rom equiv~Q$
$T sub =~~lineup ==~~ T~rp~ [ rom eclass~isom ]  $
$F sub =~~lineup ==~~ rom equiv~F$
.DE
-- Minimized DFA
.DS 1
$val~Q sub =$
  { {10, 20}, {30} }
$val~T sub =$
  { $mark 1$ : { {10, 20} : {10, 20} },
$lineup 2$ : { {10, 20} : {30} } }
$val~F sub =$
  { {30} }
.DE
The $val$ command prints the value of an identifier.
.H 1 "Gaussian Elimination"
.EQ
define RR ' roman '
define con ' RR "con" '
define transmap ' RR "transmap" '
define vecdif ' RR "vecdif" '
define scaprod ' RR "scaprod" '
define outerprod ' RR "outerprod" '
define matdif ' RR "matdif" '
define column ' RR "column" '
define unit ' RR "unit" '
define diag ' RR "diag" '
define elim ' RR "elim" '
define Gauss ' RR "Gauss" '
.EN
The matrix is represented as a vector of vectors:
.DS 2
$M~~~~=~~~~matrix { 
 rcol { < < above < above ~ above < }
 ccol { a sub 11 above a sub 21 above 3dot above a sub n1 }
 ccol { ,..., above ,..., above ~ above ,..., }
 ccol { a sub 1n , above a sub 2n , above 3dot above a sub nn , }
 ccol { b sub 1  above b sub 2  above 3dot above b sub n  }
 ccol { >, above >, above ~ above > > } }$
.DE
For the sake of simplicity we assume all the $a sub ij$
are nonzero.
We use the operator `$sel$' to select the $k$th element of
a vector.
Thus `$M~sel~k$' is the $k$th row of $M$ and
`$M~rp~[ sel~k]$' is the $k$th column of $M$.
.P
The Gauss Elimination function will use $n$ successive steps.
Each of these steps will accomplish the transformation
.DS 2
$<M,~k>~-->~<M' ,~k+1 >$
.DE
where $M prime$ is obtained from $M$ by performing the
elimination process on the $k$th column:
.DS 2
$M prime~~=~~elim~<M,~k>$
.DE
Thus the complete process is defined:
.DS 2
$Gauss~M~~=~~( elim~for~<1~to~n>)~M$
.DE
Here we make use of the functional `$(f~for~S)~x$'
which computes the sequence of values
.DS 1
$y sub 1~~mark =~~f<x,~S sub 1 >$
$y sub 2~~lineup =~~f<y sub 1 ,~S sub 2 >$
$lineup 3dot$
$y sub n~~lineup =~~f<y sub n-1 ,~S sub n >$
.DE
and returns $y sub n$.
The `for' functional is defined in terms of reduction as follows:
.DS 2
$f~for~S~~==~~[ @~S]~o~[ f~red ]$
.DE
This can be understood by the expansion:
.DS 1
$(f~for~S)~x~~mark =~~([ @~S]~o~[f~red ])~x~~=~~[ @~S]~([f~red ]~x)$
$lineup =~~[ @~S]~(f~red~x)~~=~~(f~red~x)~@~S$
$lineup =~~(f~red~x)~S$
.DE
.P
We turn now to the elimination process.
We want $M prime~=~elim~<M,~k>$, where $M prime$ results from $M$
by zeroing all entries in column $k$ of $M$, except the entry in row $k$,
which is set to one.
This can be accomplished by subtracting an appropriate matrix $E$
from $M$:
.DS 2
$M prime~~=~~matdif~<M,~E>$
.DE
Here `matdif' is a component-wise matrix difference function.
.P
The matrix $E$ is produced by multiplying the appropriate factors
by the individual rows of $M$.
For the first elimination step $E$ is:
.DS 2
$E sub 1~~~~=~~~~matrix { rcol { < above ~ above ~ above ~ }
  ccol { (1-1 / a sub 11 )M sub 1 ,
    above (a sub 21 / a sub 11 )M sub 1 ,
    above 3dot
    above (a sub n1 / a sub 11 )M sub 1 }
  lcol { ~ above ~ above ~ above > } }$
.DE
The matrix resulting from subtracting $E sub 1$ from $M$ is
.DS 2
$M sub 1~~~~=~~~~matrix { rcol { < < above < above ~ above < }
  ccol { 1, above 0, above 3dot above 0, }
  ccol { a sub 12 ' , above a sub 22 ' , above 3dot above a sub n2 ' , }
  ccol { ... above ... above ~ above ... }
  ccol { a sub 1n ' , above a sub 2n ' , above 3dot above a sub nn ' , }
  ccol { b' sub 1 above b' sub 2 above 3dot above b' sub n  }
  lcol { >, above >, above ~ above > > }}$
.DE
.P
At the next stage the elimination matrix is:
.DS 2
$E sub 2~~~~=~~~~matrix { rcol { < above ~ above ~ above ~ }
  ccol { (a sub 12 ' / a sub 22 ' )M' sub 2 ,
    above (1-1 / a sub 22 ' )M sub 2 ' ,
    above 3dot
    above (a sub n2 ' / a sub 22 ' )M sub 2 ' }
  lcol { ~ above ~ above ~ above > } }$
.DE
In general, if $M''$ is the matrix resulting from the $k-1$st
elimination step, then the elimination matrix for the $k$th step is
.DS 2
$E sub k~~~~=~~~~matrix { rcol { < above ~ above ~ above ~ above ~ }
  ccol { (a sub 1k '' / a sub kk '' )M sub k '' ,
    above 3dot
    above ([a sub kk -1] / a sub kk '' )M sub k '' ,
    above 3dot
    above (a sub nk '' / a sub kk '' )M sub k '' }
  lcol { ~ above ~ above ~ above ~ above > } }$
.DE
It is easy to see that $E sub k$ results from multiplying a vector $V sub k$
by the $k$th row of $M''$.
This is just the outer product of $V sub k$ and the $k$th row of $M''$:
.DS 2
$E sub k~~=~~outerprod~<V sub k ,~M'' sel k >$
.DE
The vector $V sub k$ is
.DS 2
$V sub k~~~~=~~~~matrix { rcol { < above ~ above ~ above ~ above ~ }
  ccol { a sub 1k '' / a sub kk '' ,
    above 3dot
    above (a sub kk '' -1) / a sub kk '' ,
    above 3dot
    above a sub nk '' / a sub kk '' }
  lcol { ~ above ~ above ~ above ~ above > }  }$
.DE
This is obtained by forming the scalar product of $1 / a sub kk ''$ and
the vector
.DS 2
$U sub k~~=~~<a sub 1k '' ,~a sub 2k '' ,..., a sub kk '' -1 ,...,
  a sub nk '' >$
.DE
This in turn is the result of subtracting from the $k$th column of $M''$
the
.ul
unit vector
$unit~<M,~k>$, which has a 1 in the $k$th position, and a 0 in all
others.
.P
We now develop an explicit relational formula for $V sub k$.
For this purpose it will be convenient to treat it as a binary function
$V sub k~=~V~<M,~k>$.
We have:
.DS 1
$V~<M,~k>~~mark =~~scaprod~< 1~/~diag~<M,~k>,~U sub k >$
$lineup =~~scaprod~<1~/~diag~<M,~k>,~vecdif~< column~<M,~k>,~unit~<M,~k> > >$
.DE
The parameter $<M,~k>$ can be factored out by use of the construction
operation `$~, bar~$', which is defined so that $(f~, bar~g)x~=~<fx,~gx>$.
Factoring, we have:
.DS 1
$V~<M,~k>~~mark =~~scaprod~<1~/~diag~<M,~k>,~vecdif~< column~<M,~k>,~unit~<M,~k> > >$
$lineup =~~scaprod~<([1~/ ]~o~diag )~<M,~k>,~vecdif~(( column~, bar~unit )~<M,~k> ) >$
$lineup =~~scaprod~<([1~/ ]~o~diag )~<M,~k>,~( vecdif~o~( column~, bar~unit ))~<M,~k> >$
$lineup =~~scaprod~((([1~/ ]~o~diag )~, bar~( vecdif~o~( column~, bar~unit )))~<M,~k> )$
$lineup =~~( scaprod~o~((1~/ ]~o~diag )~, bar~( vecdif~o~( column~, bar~unit )))~<M,~k>$
.DE
Canceling $<M,~k>$ from both sides yields an explicit formula for $V$:
.DS 2
$V~~==~~scaprod~o~(([1~/ ]~o~diag )~, bar~( vecdif~o~( column~, bar~unit )))$
.DE
.P
We proceed similarly to get a formula for $elim$:
.DS 1
$elim~<M,~k>~~mark =~~matdif~<M,~E sub k >$
$lineup =~~matdif~<M,~outerprod~<V sub k ,~M~sel~k > >$
$lineup =~~matdif~<M,~outerprod~<V~<M,~k>,~M~sel~k > >$
.DE
We perform some minor rearrangements so that $<M,~k>$ can be factored
out of the right-hand side:
.DS 1
$elim~<M,~k>~~mark =~~matdif~<M,~outerprod~<V~<M,~k>,~[ sel ]~<M,~k> > >$
$lineup =~~matdif~<M,~( outerprod~o~(V~, bar~[ sel ]))~<M,~k> >$
$lineup =~~matdif~<[ sel~1]~<M,~k>,~( outerprod~o~(V~, bar~[ sel ]))~<M,~k> >$
$lineup =~~( matdif~o~([ sel~1]~, bar~( outerprod~o~(V~, bar~[ sel ]))))~<M,~k>$
.DE
Canceling $<M,~k>$ from both sides yields an explicit formula for $elim$:
.DS 2
$elim~~==~~matdif~o~([ sel~1]~, bar~( outerprod~o~(V~, bar~[ sel ])))$
.DE
.P
A complete RPL session demonstrating the Gaussian elimination
function follows:
.SK
-- Utility Functions
.DS 1
         $con~k~~mark ==~~ func~x~k $
$transmap~f~~lineup ==~~  [ rp~f ] ~o~ [ # ]  $
$vecdif~~lineup ==~~ transmap~ [ - ]  $
$scaprod~ < k,~v > ~~lineup ==~~ v~rp~ [ k~times ]  $
$outerprod~ < u,~v > ~~lineup ==~~ u~rp~ ( scaprod~o~ [ ,~v ]  )  $
$matdif~~lineup ==~~ transmap~vecdif $
$column~ < M,~k > ~~lineup ==~~ M~rp~ [ sel~k ]  $
$unit~ < M,~k > ~~lineup ==~~  < 1~to~  card~M  > ~rp~ [  [ =~k ] ~->~ con~1 ;~ con~0 ]  $
$diag~ < M,~k > ~~lineup ==~~  M~sel~k ~sel~k $
$f~for~S~~lineup ==~~  [ @~S ] ~o~ [ f~red ]  $
.DE
-- Gaussian Elimination
.DS 1
$V~~lineup ==~~ scaprod~o~ (  (  [ 1.0~divide ] ~o~diag ) ~ , bar ~ ( vecdif~o~ ( column~ , bar ~unit )  )  )  $
$elim~~lineup ==~~ matdif~o~ (  [ sel~1 ] ~ , bar ~ ( outerprod~o~ ( V~ , bar ~ [ sel ] ~ )  )  )  $
$Gauss~M~~lineup ==~~  ( elim~for~ <1~to~ card~M >  ) ~M $
.DE
-- Example Matrix
.DS 1
$M~~lineup ==~~ <  < 3,~9,~33 >, ~ < 2,~-1,~1 > >  $
.DE
-- Execution
.DS 1
$Gauss~M$

  $matrix { rcol { < <~1.0, above <~0.0, }
    ccol { -2.38419 rom E -7, above 1.0, }
    lcol { 2.0 > above 3.0 > >} }$
.DE
The matrix $M$ represents the equations
.DS 1
$3x~+~9y~~mark =~~33$
$2x~-~y~~lineup =~~1$
.DE
The result of $Gauss~M$ correctly reflects the solution $x~=~2$, $y~=~3$.
.H 1 "Employee File Update"
Next we consider a simple data processing example adapted from [MacLennan83].
We are given an employee file $F$ indexed by employee number.
That is, $F~sel~n$ is the record for employee number $n$.
The employee records themselves are represented by functions from
attribute names into attribute values.
For example, if $R$ is an employee record, then $R~sel~LQ rom N RQ$
is the employee's name, $R~sel~LQ rom R RQ$ is his hourly rate,
and $R~sel~LQ rom H RQ$ is the hours worked this pay period.
Here is an example employee file containing three records:
.DS 1
$F~~==~mark~${124 : {``N'' : ``John'', ``R'' : 10, ``H'' : 100},
$lineup~$  118 : {``N'' : ``Bill'', ``R'' : 15, ``H'' : 120},
$lineup~$  207 : {``N'' : ``Sally'', ``R'' : 14, ``H'' : 115}}
.DE
We are also given an update file $U$ such that $U~sel~n$ is the
number of hours worked this week by employee number $n$.
For example:
.DS 1
$U~~==~~ "{"   118~:~6 , ~  124~:~40 , ~  207~:~40 "}"$
.DE
Our task is to generate an updated employee file $F'$ in which
the hours worked (``H'') field has been updated.
.P
First we define `$rom sumhrs$' so that if $R$ is
an employee record and $h$ is the hours worked this week, then
$rom sumhrs~<R,~h>$ is the new total hours.
Clearly,
.DS 2
$rom sumhrs~<R,~h>~~==~~(R~sel~LQ rom H RQ )~+~h$
.DE
Alternately, we can define this function variable-free style:
.DS 2
$rom sumhrs~~==~~[ + ]~o~([ sel~LQ rom H RQ ]~||~I )$
.DE
It is easy to see the two are equivalent:
.DS 1
$rom sumhrs~<R,~h>~~mark =~~([ + ]~o~([ sel~LQ rom H RQ ]~||~I ))~<R,~h>$
$lineup =~~[ + ]~(( [ sel~LQ rom H RQ ]~||~I )~<R,~h>)$
$lineup =~~[ + ]~< [ sel~LQ rom H RQ ]~R,~I~h>$
$lineup =~~(R~sel~LQ rom H RQ )~+~h$
.DE
.P
Our next task is to replace the old value of ``H'' field by $h'$.
This can be accomplished by the
.ul
ordered union
operation `$;$'.
For example, 
.DS 2
{``H'' : $h'$} ; $R$
.DE
will return a record $R'$ in which $R'~sel~LQ rom H RQ$ = $h'$
but all other fields of $R'$ are the same as in $R$.
How do we get the relation {``H'' : $h'$}?
Since this is just a sequence that's equivalent to the 
array $< LQ rom H RQ ,~h' >$,
we can use $as$ to convert the array to a sequence.
We solve for the function $f$ that computes {``H'' : $h'$} from
$<R,~h>$ as follows:
.DS 1
$f~<R,~h>~~mark =~~"{" LQ rom H RQ~:~rom sumhrs~<R,~h> "}"$
$lineup =~~as~< LQ rom H RQ ,~rom sumhrs~<R,~h> >$
$lineup =~~as~( [ LQ rom H RQ~, ]~( rom sumhrs~<R,~h> ) )$
$lineup =~~( as~o~[ LQ rom H RQ~, ]~o~rom sumhrs )~<R,~h>$
.DE
Hence,
.DS 2
$f~~==~~as~o~[ LQ rom H RQ~, ]~o~rom sumhrs$
.DE
.P
It's necessary to get the corresponding records from the $F$ and $U$
files together so that they can be processed by $f$.
This is accomplished by the extensional construction operation $#$
defined so that $(F~#~U)~sel~n$ = $<F~sel~n,~U~sel~n>$.
With the given example files we have:
.DS 1
$F~#~U~~=~~mark "{"$ 124 : <{``N'' : ``John'', ``R'' : 10, ``H'': 100}, 40>,
$lineup~$ 118 : <{``N'' : ``Bill'', ``R'' : 15, ``H'' : 120}, 6>,
$lineup~$ 207 : <{``N'' : ``Sally'', ``R'' : 14, ``H'' : 115}, 40>}
.DE
Notice that the pairs $<F~sel~n,~U~sel~n>$ are just the inputs
required for $f$.
We combine the preceding results into a update file `$rom upd$'
defined so that $rom upd~sel~n$ is {``H'' : $h'$},
representing the new hours worked for employee number $n$.
In this case,
.DS 1
$rom upd~~=~~mark "{"$ 124 : {``H'' : 140},
$lineup~$ 118 : {``H'' : 126},
$lineup~$ 207 : {``H'' : 155}}
.DE
It's easy to solve for $rom upd$ by using the relative product:
.DS 1
$rom upd~sel~n~~mark =~~f~( (F~#~U)~sel~n)$
$lineup =~~((F~#~U)~rp~f)~sel~n$
.DE
Hence, $rom upd~=~(F~#~U)~rp~f$.
Substituting for $f$ yields:
.DS 2
$rom upd~~==~~(F~#~U)~rp~( as~o~[ LQ rom H RQ~, ]~o~rom sumhrs )$
.DE
Now we're almost done.
We want each record in $F'$ to be the ordered union of the
corresponding update record in $rom upd$ and old record in $F$.
Hence we solve:
.DS 1
$F'~sel~n~~mark =~~( rom upd~sel~n )~;~(F~sel~n)$
$lineup =~~[ ; ]~< rom upd~sel~n,~F~sel~n>$
$lineup =~~[ ; ]~(( rom upd~#~F)~sel~n)$
$lineup =~~(( rom upd~#~F)~rp~[ ; ])~sel~n$
.DE
Hence,
.DS 2
$F'~~=~~( rom upd~#~F)~rp~[ ; ]$
.DE
The complete session follows:

-- The Files
.DS 1
$F~~==~mark~${124 : {``N'' : ``John'', ``R'' : 10, ``H'' : 100},
$lineup~$  118 : {``N'' : ``Bill'', ``R'' : 15, ``H'' : 120},
$lineup~$  207 : {``N'' : ``Sally'', ``R'' : 14, ``H'' : 115}}

$U~~==~~ "{"   118~:~6 , ~  124~:~40 , ~  207~:~40 "}"$
.DE
-- Computing the New File
.DS 1
$rom sumhrs~~mark ==~~  [ + ] ~o~ (  [ sel~LQ rom H RQ ] ~||~I ) $

$rom upd~~lineup ==~~  ( F~#~U ) ~rp~ ( as~o~  [ LQ rom H RQ~, ] ~o~rom sumhrs  ) $

$F'~~lineup ==~~  ( rom upd~#~F ) ~rp~ [ ; ]   $
.DE
-- The New File
.DS 1
$val~F'$

  {$mark 124$ : {``H'' : 140, ``N'' : ``John'', ``R'' : 10},
$lineup 118$ : {``H'' : 126, ``N'' : ``Bill'', ``R'' : 15},
$lineup 207$ : {``H'' : 155, ``N'' : ``Sally'', ``R'' : 14} }
.DE
This result correctly reflects the fact that John (employee 124) has worked
124 hours, Bill (employee 118) has worked 15 hours,
and Sally (employee 207) has worked 14 hours.
.P
It is simple to modify the program so that it uses the input files
OldMaster and Updates, and defines the output file NewMaster:
.DS 1
$~~~~~~~~F~~mark ==~~file~LQ rom OldMaster RQ$
$U~~lineup ==~~file~LQ rom Updates RQ$
$rom sumhrs~~lineup ==~~[ + ]~o~([ sel~LQ rom H RQ ]~||~I )$
$rom upd~~lineup ==~~(F~#~U)~rp~( as~o~[ LQ rom H RQ~, ]~o~rom sumhrs$
$file~lineup LQ rom NewMaster RQ~~==~~( rom upd~#~F)~rp~[ ; ]$
.DE
.H 1 "References"
.VL 4
.LI [Brown&Mitton]
Brown, J. R., and Mitton, S. J.,
.ul
Relational Programming:  Design and Implementation of a Prototype Interpreter,
MS thesis, Naval Postgraduate School, June 1985.
.LI [MacLennan83]
MacLennan, B. J.,
``Relational Programming,''
Naval Postgraduate School Computer Science Department Technical Report
NPS52-83-012, September 1983.
.LE
.SK
.DS 2
.B "APPENDIX A:  EXAMPLE RPL SESSIONS"
.DE
This appendix contains transcripts of actual RPL sessions with the Brown
and Mitton interpreter.
Note that the interpreter follows the Interlisp convention of
permitting a bracket `\f5]\f1' to close any number of open parentheses.
.DS 2
.B "Example 1:  Word Frequence"
.DE
It will be seen that the RPL interpreter computes a relation containing
redundant tuples.
They do no harm, but can be eliminated (by a quadratic algorithm) if
desired.
The transcript follows:
.sp
.ft 5
.nf
Loading RPL--- DO YOU WANT TO RESUME A PREVIOUS RPL SESSION? <y/n> n


RPL INTERPRETER ON LINE!! 

?> S == (list "to" "be" "or" "not" "to" "be"]

?> (S sup -1]

 ( rel  ( be  6 )  ( to  5 )  ( not  4 )  
  ( or  3 )  ( be  2 )  ( to  1 ) ) 

?> unimage T == ((dom T) restrict (lsec T unimg]

?> (unimage (S sup -1]

 ( set  ( be  ( set  6  2 ) )  ( to  ( set  5  1 ) )  
  ( not  ( set  4 ) )  ( or  ( set  3 ) )  
  ( be  ( set  6  2 ) )  ( to  ( set  5  1 ) ) ) 

?> ((unimage (S sup -1)) rp size]

 ( rel  ( be  2 )  ( to  2 )  ( not  1 )  ( or  1 )  
  ( be  2 )  ( to  2 ) ) 

?> freq S == ((unimage (S sup -1)) rp size]

?> (freq (list "to" "be" "or" "not" "to" "be"]

 ( rel  ( be  2 )  ( to  2 )  ( not  1 )  ( or  1 )  
  ( be  2 )  ( to  2 ) ) 

?> done

DO YOU WANT TO SAVE ENVIRONMENT FOR FUTURE USE? <y/n> n

.fi
.ft 1
.SK
.DS 2
.B "Example 2:  Minimizing DFA"
.DE
For this example we assume that commands for defining the DFA and
performing the minimization are on a file, ``examples/dfa.rpl'',
whose contents are:
.nf
.ft 5

(1st == (rsec sel 1))
(2nd == (rsec sel 2))
(r ppd s == (r | (s | (cnv r))))
(sigma f == ((f o (1st (, bar) (epsilon o 2nd))) (, bar) ((op \) o ((I (, bar) (un o epsilon)) o 2nd))))
(f rho i == (1st o (((sigma f) while ((rsec != empty) o 2nd)) o (lsec i ,))))
(union == ((op cup) rho empty))
(SIGMA == (set 1 2))
(T == (rel (1 : (rel (10 : 10) (20 : 20))) (2 : (rel (10 : 30) (20 : 30)))))
(Q == (set 10 20 30))
(F == (set 30))
(Q_sup_2 == (Q cart Q))
(n == (size Q_sup_2))
(R_sub_0 == (F cart (Q \ F)))
(psi R == (R cup (union (rng (T rp (rsec ppd R))))))
(R_sub_inf == ((psi sup n) R_sub_0))
(R_sub_= == ((Q_sup_2 \ R_sub_inf) cap (Q_sup_2 \ (cnv R_sub_inf))))
(rom_eclass == (lsec R_sub_= unimg))
(rom_equiv == (lsec rom_eclass img))
(Q_sub_= == (rom_equiv Q))
(T_sub_= == (T rp (lsec rom_eclass $isom$)))
(F_sub_= == (rom_equiv F))
EOF

.fi
.ft 1
This file is executed by being loaded into RPL.
The resulting transition function and states of the minimal machine
are then displayed.
They can be seen to be sets of sets, since the states in the minimal
machine are represented by equivalence classes.\*F
.FS
Note that as usual there is benign redundancy in the sets.
.FE
The transcript follows:
.ft 5
.nf

DO YOU WANT TO RESUME A PREVIOUS RPL SESSION? <y/n> y
INPUT FILENAME 
examples/dfa.rpl
Loading--- Session loaded 
?> val Q_sub_=

 ( set  ( set  10  20 )  ( set  10  20 )  ( set  30 ) ) 

?> val T_sub_=

 ( rel  ( 1  ( rel  ( ( set  10  20 )  ( set  10  20 ) )  ( ( set  10  20 )  ( 
 set  10  20 ) ) ) )  ( 2  ( rel  ( ( set  10  20 )  ( set  30 ) )  ( ( set  10  
 20 )  ( set  30 ) ) ) ) ) 

?> val F_sub_=

 ( set  ( set  30 ) ) 

?> done

.fi
.ft 1
.SK
.DS 2
.B "Example 3:  Gaussian Elimination"
.DE
The program for performing the Gaussian elimination is in the
file ``examples/gauss.rpl'', whose contents are:

.nf
.ft 5
(con k == (func x k))
(transmap f == ((rsec rp f) o (op #)))
(vecdif == (transmap (op -)))
(scaprod (k v) == (v rp (lsec k times)))
(outerprod (u v) == (u rp (scaprod o (rsec , v))))
(matdif == (transmap vecdif))
(column (M k) == (M rp (rsec sel k)))
(unit (M k) == ((listrange 1 to (size M)) rp (if (rsec = k) -> (con 1) ; (con 0))))
(diag (M k) == ((M sel k) sel k))
(f for S == ((rsec @ S) o (lsec f red)))
(V == (scaprod o (((lsec 1.0 divide) o diag) (, bar) (vecdif o (column (, bar) unit)))))
(elim == (matdif o ((rsec sel 1) (, bar) (outerprod o (V (, bar) (op sel) )))))
(Gauss M == ((elim for (listrange 1 to (size M))) M))
(M == (list (list 3 9 33) (list 2 -1 1)))
(a == (diag (list M 1)))
(b == (vecdif (list (column (list M 1)) (unit (list M 1)))))
(v == (scaprod (list 0.33 b)))
EOF

.fi
.ft 1
The session shown in the following transcript performs the Gaussian elimination
on the matrix $M$:

.nf
.ft 5
DO YOU WANT TO RESUME A PREVIOUS RPL SESSION? <y/n> y
INPUT FILENAME 
examples/gauss.rpl
Loading--- Session loaded 
?> (Gauss M]

 ( rel  ( 1  ( rel  ( 1  1.0 )  ( 2  -2.38419E-07 )  ( 3  2.0 ) ) )
  ( 2  ( rel  ( 1  0.0 )  ( 2  1.0 )  ( 3  3.0 ) ) ) ) 

?> done

.fi
.ft 1
Note that the resulting matrix is printed as a relation rather than a
list of lists, since it is quite expensive for the interpreter to
determine if a relation is in fact a list.
.SK
.DS 2
.B "Example 4:  Data Processing"
.DE
In this example, the employee file to be updated is small (three records),
and so typed in interactively.
More typically, the RPL $file$ facility would be used to load $F$ from disk.
The transcript follows:
.nf
.ft 5

RPL INTERPRETER ON LINE!! 
?> F == (rel (124 :
 (rel ("N" : "John") ("R" : 10) ("H" : 100)))
(118 :
 (rel ("N" : "Bill") ("R" : 15) ("H" : 120)))
(207 :
 (rel ("N" : "Sally") ("R" : 14) ("H" : 115]

?> U == (rel (118 : 6) (124 : 40) (207 : 40]

?> (F # U]

 ( rel  ( 124  ( rel  
   ( 1  ( rel  ( N  John )  ( R  10 )  ( H  100 ) ) )  
   ( 2  40 ) ) )  
  ( 118  ( rel  
   ( 1  ( rel  ( N  Bill )  ( R  15 )  ( H  120 ) ) )  
   ( 2 6 ) ) )  
  ( 207  ( rel  
   ( 1  ( rel  ( N  Sally )  ( R  14 )  ( H  115 ) ) )  
   ( 2 40 ) ) ) ) 
?> sumhrs == ((op +) o ((rsec sel "H") || I]

?> upd == ((F # U) rp 
     (as o ((lsec "H" ,) o sumhrs]

?> F' == ((upd # F) rp (op ;]

?> val F'

 ( rel  ( 124
   ( rel  ( H  140 )  ( N  John )  ( R  10 ) ) )  
  ( 118  
   ( rel  ( H 126 )  ( N  Bill )  ( R  15 ) ) )  
  ( 207  
   ( rel  ( H  155 )  ( N  Sally )  ( R 14 ) ) ) ) 

?> done
.ft 1
.fi
.SK
.DS 2
.B "APPENDIX B:  RPL GRAMMAR"
.DE
.EQ
define ALT ' left { lpile {~ '
define OR ' above~ '
define ENDALT ' }~right } '
define OPT ' left [ lpile {~ '
define ENDOPT ' }~right ] '
define infix ' "infix" '
define infixop ' "infixop" '
define prefixid ' "prefixid" '
define prefixop ' "prefixop" '
define identifier ' "identifier" '
.EN
.SP 2
.nf
			$session~~=~~command sup *~bold done$
.sp
			$command~~=~~ALT prefixid~[ identifier ]~==~expression
  OR bold display~expression ENDALT$
.sp
			$expression~~=~~ALT [ expression~infix ]~application
  OR superscription ENDALT$
.sp
			$application~~=~~ALT [ application ]~primary
  OR bold iter~' [ '~primary~->~primary~' ] ' ENDALT$
.sp
			$superscription~~=~~expression~bold "sup"~ALT application
    OR + OR * ENDALT$
.sp
			$primary~~=~~ALT literal
  OR prefixid
  OR ' [ '~ALT infix
    OR infix~primary
    OR primary~infix 
    OR primary~->~primary~;~primary ENDALT~' ] '
  OR fat (~expression~[ ..~expression ]~fat )
  OR fat "{"~expression~[ ..~expression ]~fat "}"
  OR <~primary~,~...~>
  OR bold file~string ENDALT$
.sp
			$infix~~=~~infixop~[ bold "bar" ]$
.sp
			$identifier~~=~~letter~OPT letter OR digit ENDOPT sup *~"prime" sup *$
.sp
			$"prime"~~=~~prime$
.sp
			$literal~~=~~ALT digit sup +~[ fat .~digit sup + ]~[ bold E~[~+~|~-~]~digit sup + ]
  OR string OR bold true OR bold false ENDALT$
.sp
			$string~~=~~$``$~char sup *~$''
.sp
		
		$infixop~~=~~$ 
		  sel | , : cup member nomem !subset subset = -> <- restr ; cl cr cap \e
		  @hat ! cat @ . | | $dollar$ red + - times divide != < > <= >=
		  andsign orsign cart
.sp
		$prefixid~~=~~ALT identifier OR prefixop ENDALT$
.sp
		$prefixop~~=~~$
		  - un cur unc theta size str DELTA inv dom rng mem Lm Rm Mm run lun bun
		  init term alpha omega ALPHA OMEGA min max mu index select join as sa sa0
		  rp rpi rsort sort unimg all ssm img curry uncurry PHI Id while upsilon
		  phi delta PI extend restrict wig not
.fi
.SK
.DS 2
.B "APPENDIX C:  RPL INPUT FORM SUMMARY"
.DE
.S
.SP 2
.DS  2
.TB "Primitive Extensional Operations"
.DE
.DS
.TS
center,box;
l|l|l|l.
Name	Old Input Form	New Input Form	Publication Form
_
selection	t sel x	t sel x	$t~sel~x$
relative product	t | u	t | u	$t~|~u$
construction	t , bar u	t # u	$t~#~u$
pair formation	x : y	x : y	$x~:~y$
union	t cup u	t cup u	$t~cup~u$
unit set	un x	un x	$rom un~x$
currying	cur t	cur t	$rom cur~t$
uncurrying	unc t	unc t	$rom unc~t$
unique element selection	theta s	theta s	$theta~s$
element selection	(added)	epsilon t	$epsilon~t$
cardinality	size t	size t	$rom "size"~t$
structure	str t	(deleted)	(deleted)
transitive closure	t sup +	t sup +	$t sup +$
empty set	empty	empty	$empty$
.TE
.DE
.bp
.DS  2
.TB "Nonprimitive Extensional Operations:  Group 1"
.DE
.DS
.TS
center,box;
l|l|l|l.
Name	Old Input Form	New Input Form	Publication Form
_
pair list	(x, y)	(x , y)	$(x,~y)$
left pair section	(x,)	(deleted)	(deleted)
right pair section	(,y)	(deleted)	(deleted)
duplication	DELTA x	DELTA x	$DELTA~x$
membership	x member t	x member t	$x~member~t$
nonmembership	x nomem t	x nomem t	$x~nomem~t$
improper subset	s !subset t	s !subset t	$s~!subset~t$
proper subset	s subset t	s subset t	$s~subset~t$
equality	s = t	s = t	$s~=~t$
converse	inv t, t sup -1	cnv t, t sup -1	$rom cnv~t,~t sup -1$
domain	dom t	dom t	$rom dom~t$
range	rng t	rng t	$rom rng~t$
members	mem t	mem t	$rom mem~t$
left member	Lm (x,t)	x Lm t	$x~rom Lm~t$
right member	Rm (x,t)	x Rm t	$x~rom Rm~t$
member	Mm (x,t)	x Mm t	$x~rom Mm~t$
right univalent	run t	run t	$rom run~t$
left univalent	lun t	lun t	$rom lun~t$
bi-univalent	bun t	bun t	$rom bun~t$
initial members	init t	init t	$rom init~t$
terminal members	term t	term t	$rom term~t$
reflexive transitive closure	t sup *	t sup **	$t sup *$
domain restriction	p -> t	p -> t	$p~->~t$
range restriction	t <- p	t <- p	$t~<-~p$
restriction	t restr p	t restr p	$t~restr~p$
sequence filtering	(added)	p xi t 	$p~xi~t$
.TE
.DE
.SK
.DS  2
.TB "Nonprimitive Extensional Operations:  Group 2"
.DE
.DS
.TS
center,box;
l|l|l|l.
Name	Old Input Form	New Input Form	Publication Form
_
first member	alpha t	alpha t	$alpha~t$
last member	omega t	omega t	$omega~t$
initial sequence	ALPHA t	ALPHA t	$ALPHA~t$
final sequence	OMEGA t	OMEGA t	$OMEGA~t$
ordered union	t ; u	t ; u	$t~;~u$
cons left	x cl t	x cl t	$x~rom cl~t$
cons right	t cr x	t cr x	$t~rom cr~x$
minimum	min s	min s	$rom min~s$
maximum	max s	max s	$rom max~s$
intersection	s cap t	s cap t	$s~cap~t$
set difference	s \e t	s \e t	$s~"\e"~t$
apply functional record	t @ hat x	t @hat x	$t~@hat~x$
apply functional structure	t ! x	t ! x	$t~!~x$
minimize	mu t	mu t	$mu~t$
database index	index x d	x index d	$x~rom index~d$
database select	select x	x select d	$x~rom select~d$
database join	join x	x join dblist	$x~rom join~dblist$
array to sequence	as t	as t	$rom as~t$
sequence to array	sa t	t sa i	$t~rom sa~i$
seq. to zero-origin array	sa0 t	(deleted)	(deleted)
relative product	rp f t	t rp f 	$t~rom rp~f$
relative product inverse	rpi f t	f rpi t	$f~rom rpi~t$
array concatenation	t cat u	t cat u	$t~rom cat~u$
relation sort	rsort s	rsort s	$rom rsort~s$
sort	sort s	sort s	$rom sort~s$
unit image	unimg t x	t unimg x	$t~rom unimg~x$
all	all t	all t	$rom all~t$
sequence to matrix	ssm t	ssm t	$rom ssm~t$
.TE
.DE
.SP 1
.DS  2
.TB "Primitive Intensional Operations"
.DE
.DS
.TS
center,box;
l|l|l|l.
Name	Old Input Form	New Input Form	Publication Form
_
application	f @ x	f @ x	$f~@~x$
image	img f s	f img s	$f~rom img~s$
composition	f . g	f o g	$f~o~g$
infix to prefix	(added)	(op +), (op times), ...	$[+],~[ times ],~...$
left section	(x+), (x-), ...	(lsec x +), (lsec x -), ...	$[x+],~[x-],~...$
right section	(+y), (-y), ...	(rsec + y), (rsec - y), ...	$[+y],~[-y],~...$
paralleling	f | | g	f | | g	$f~||~g$
isomorphism	f $dollar$ t	f $dollar$ t	$f~dollar~t$
formal application	f @ bar g	(deleted)	(deleted)
functional condition	(p -> f; g)	(if p -> f ; g)	$(p~->~f;~g)$
curry	curry f	curry f	$rom curry~f$
uncurry	uncurry f	uncurry f	$rom uncurry~f$
filtering	PHI p (d, r)	p PHI S	$p~PHI~S$
iteration	iter [p -> f]	(iter p -> f)	$rom iter~[p~->~f]$
formalization	+ bar, times bar, ...	(+ bar), (times bar), ...	$+ bar ,~times bar$, ...
identity	Id	I	$rom I$
.TE
.DE
.SK
.DS  2
.TB "Nonprimitive Intensional Operations"
.DE
.DS
.TS
center,box;
l|l|l|l.
Name	Old Input Form	New Input Form	Publication Form
_
while loop	while [p, f]	(f while p)	$f~rom while~p$
array reduction	f red i	f red x	$f~red~x$
repeated composition	f sup n	f sup n	$f sup n$
value of node	upsilon f	upsilon f	$upsilon~f$
operate on form	phi f	phi f	$phi~f$
operate on data	delta f	delta f	$delta~f$
image of structure	PI f	PI f	$PI~f$
extension	extend (t, f)	t extend f	$t~rom extend~f$
restriction	restrict (s, f)	s restrict f	$s~rom restrict~f$
formal negation	wig p	wig p	$wig p$
.TE
.DE
.SP 1
.DS  2
.TB "Miscellaneous Operations"
.DE
.DS
.TS
center,box;
l|l|l|l.
Name	Old Input Form	New Input Form	Publication Form
_
sum	x + y	x + y	$x~+~y$
difference	x - y	x - y	$x~-~y$
product	x times y	x times y	$x~times~y$
quotient	x divide y	x divide y	$x~divide~y$
inequality	x != y	x != y	$x~!=~y$
less	x < y	x < y	$x~<~y$
greater	x > y	x > y	$x~>~y$
less or equal	x <= y	x <= y	$x~<=~y$
greater or equal	x >= y	x >= y	$x~>=~y$
conjunction	x andsign y	x andsign y	$x~andsign~y$
disjunction	x orsign y	x orsign y	$x~orsign~y$
negation	not x	not x	$not x$
cartesian product	s cart t	s cart t	$s~cart~t$
.TE
.DE
.SP 1
.DS  2
.TB "Data Input Operations and Syntax"
.DE
.DS
.TS
center,box;
l|l|l.
Name	Input Form	Publication Form
_
identifiers	a, b', total, etc.	$a,~b',~rom total ,~etc.$
strings	``abcd''	``abcd''
booleans	true, false	$true ,~false$
relation	(rel (x : y), ... )	$((x~y),~...~)$
set	(set x y ... )	$"{"x,~y,~...~"}"$
sequence	(seq x y ... )	$(x,~y,~...~)$
list	(list x y ... )	$<x,~y,~...~>$
subrange set	(setrange m to n)	$"{"m ,..., n"}"$
subrange sequence	(seqrange m to n)	$(m ,..., n)$
subrange list	(listrange m to n)	$"<"m ,..., n">"$
.TE
.DE
.SK
.DS  2
.TB "RPL Command Types"
.DE
.DS
.TS
center,box;
l|l|l.
Name	Input Form	Publication Form
_
data definition	x == y	$x~==~y$
prefix function definition	f x == y	$f~x~==~y$
infix function definition	x f y == z	$x~f~y~==~z$
write data to a file	file "name" == x	$file~``name$''$~==~x$
read data from a file	x == (file "name")	$x~==~file~``name$''
output, form 1	display x	$display~x$
output, form 2	dis x	$dis~x$
output, form 3	d x	$BB d~x$
output, form 4	x	$x$
output value of definition	val x	$val~x$
output function environment	env f	$env~f$
output entire environment	env	$env$
.TE
.DE
.S -1
.SK
.ls 1
.DS 2
INITIAL DISTRIBUTION LIST
.DE
.EQ
define ue ' roman u dotdot '
define ae ' roman a dotdot '
.EN
.sp 2
.TS
expand;
l r.
Defense Technical Information Center
Cameron Station
Alexandria, VA 22314	2

Dudley Knox Library
Code 0142
Naval Postgraduate School
Monterey, CA 93943	2

Office of Research Administration
Code 012A
Naval Postgraduate School
Monterey, CA 93943	1

Chairman, Code 52
Department of Computer Science
Naval Postgraduate School
Monterey, CA 93943	40

Bruce J. MacLennan
Code 52ML
Department of Computer Science
Naval Postgraduate School
Monterey, CA 93943	12

Ralph Wachter
Code 433
Office of Naval Research
800 N. Quincy
Arlington, VA 22217-5000	1

S. Kamal Abdali
Tektronix Laboratories
Computer Research Laboratory
M/S 50-662
P. O. Box 500
Beaverton, OR 97077	1

Drew D. Adams
Centre de Recherches de la C.G.E.
Laboratories de Marcoussis
Division Informatique
Route de Nozay
91460 Marcoussis
France	1

Vinay Apsingikar
CMC Limited
R & D Division
115 Sarojini Devi Road
Secunderabad 500003
India	1

John Backus
IBM Almaden Research Center
650 Harry Road
San Jose, CA 95120-6099	1

Jospeh H. Fasel
Los Alamos National Laboratory
C-10, MS B296
Los Alamos, NM 87545	1

Robert Floyd
Computer Science Department
Stanford University
Stanford, CA 94305	1

Joseph A. Goguen
SRI International
Computer Science Laboratory
333 Ravenswood Avenue
Menlo Park, CA 94025	1

Peter Henderson
Department of Computer Science
SUNY at Stony Brook
Long Island, NY 11794	1

Paul Hudak
Yale University
Department of Computer Science
Box 2158, Yale Station
New Haven, CT 06520	1

Bharat Jayaraman
University of North Carolina
Department of Computer Science
New West Hall 035 A
Chapel Hill, NC 27514	1

A. Dain Samples
Computer Science Division - EECS
University of California
Berkeley, CA 94720	1

Mayer Schwartz
Computer Research Laboratory
MS 50-662
Tektronix, Inc.
P. O. Box 500
Beaverton, OR 97077	1

Guy L. Steele
Thinking Machines Corporation
245 First Street
Cambridge, MA 02142	1

Richard Taylor
INMOS Limited
Whitefriars
Lewins Mead
Bristol BS1 2NP
UK	1
